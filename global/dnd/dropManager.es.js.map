{"version":3,"file":"dropManager.es.js","sources":["../../../src/global/dnd/dropManager.ts"],"sourcesContent":["import { BoardData, BoardItem, DropParams } from \"@/components\";\nimport { extractClosestEdge } from \"@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge\";\nimport { reorderWithEdge } from \"@atlaskit/pragmatic-drag-and-drop-hitbox/util/reorder-with-edge\";\n\nconst isCardData = (data) => data?.type === \"card\";\nconst isColumnData = (data) => data?.type === \"column\";\n\nconst getTasksByColumnId = (columnId: string, dataSource: BoardData) => {\n  const tasks: BoardItem[] = [];\n  const column = dataSource[columnId];\n  if (!column) return tasks;\n  const parentTasks = column.children;\n  parentTasks?.forEach((taskId) => {\n    const task = dataSource[taskId];\n    if (task) tasks.push(task);\n  });\n  return tasks;\n};\n\nexport const handleCardDrop = ({\n  source,\n  location,\n  columns,\n  dataSource,\n  onCardMove,\n  onColumnMove,\n}: DropParams) => {\n  if (isColumnData(source.data)) {\n    if (!onColumnMove) return;\n\n    const sourceColumnId = source.data.columnId;\n    // const sourceIndex = source.data.index\n\n    // Find innermost drop target\n    //@ts-ignore\n    const innerMost = location.current.dropTargets[0];\n    if (!innerMost) return;\n\n    const dropTargetData = innerMost.data;\n\n    // Only proceed if dropping on another column\n    if (isColumnData(dropTargetData)) {\n      const targetColumnId = dropTargetData.columnId;\n      const targetIndex = columns.findIndex((col) => col.id === targetColumnId);\n\n      if (targetIndex === -1) return;\n\n      // Don't reorder if dropped on itself\n      if (sourceColumnId === targetColumnId) return;\n\n      // Call the provided onColumnMove handler\n      onColumnMove?.({\n        columnId: sourceColumnId,\n        fromIndex: columns.findIndex((col) => col.id === sourceColumnId),\n        toIndex: targetIndex,\n      });\n    }\n\n    return;\n  }\n\n  // Handle card reordering\n  if (!isCardData(source.data)) {\n    return;\n  }\n\n  const draggingCardId = source.data.itemId;\n  const sourceColumnId = source.data.columnId;\n  // const sourceCardIndex = source.data.index\n\n  // Find innermost drop target (card or column)\n  const innerMost = location.current.dropTargets[0];\n  if (!innerMost) return;\n\n  const dropTargetData = innerMost.data;\n\n  // Case 1: Dropping on another card\n  if (dropTargetData[\"card-drop-target\"]) {\n    const targetColumnId = dropTargetData.columnId;\n    const targetCardId = dropTargetData.itemId;\n    const closestEdge = extractClosestEdge(dropTargetData);\n\n    // Find the cards involved\n    const sourceColumn = dataSource[sourceColumnId];\n    const targetColumn = dataSource[targetColumnId];\n\n    if (!sourceColumn || !targetColumn) return;\n\n    // For same column reordering\n    if (sourceColumnId === targetColumnId) {\n      // Get all tasks in the column\n      const allTasks = getTasksByColumnId(targetColumnId, dataSource);\n\n      // Find source and target indices\n      const sourceIndex = allTasks.findIndex(\n        (task) => task.id === draggingCardId,\n      );\n      const targetIndex = allTasks.findIndex(\n        (task) => task.id === targetCardId,\n      );\n\n      if (sourceIndex === -1 || targetIndex === -1) return;\n\n      // No change needed if same position\n      if (sourceIndex === targetIndex) return;\n\n      // Use reorderWithEdge to get the correct new order\n      const reordered = reorderWithEdge({\n        axis: \"vertical\",\n        list: allTasks,\n        startIndex: sourceIndex,\n        indexOfTarget: targetIndex,\n        closestEdgeOfTarget: closestEdge,\n      });\n\n      // Calculate the new position based on the reordered array\n      const newPosition = reordered.findIndex(\n        (task) => task.id === draggingCardId,\n      );\n\n      // Find tasks above and below the insertion point\n      const taskAbove = newPosition > 0 ? reordered[newPosition - 1] : null;\n      const taskBelow =\n        newPosition < reordered.length - 1 ? reordered[newPosition + 1] : null;\n\n      // Call the provided onCardMove handler\n      if (onCardMove) {\n        onCardMove({\n          cardId: draggingCardId,\n          fromColumnId: sourceColumnId,\n          toColumnId: targetColumnId,\n          taskAbove: taskAbove?.id,\n          taskBelow: taskBelow?.id,\n          position: newPosition,\n        });\n      }\n    }\n    // Moving between columns\n    else {\n      // Get all tasks in the target column\n      const allTargetTasks = getTasksByColumnId(targetColumnId, dataSource);\n\n      // Find the target task index\n      const targetIndex = allTargetTasks.findIndex(\n        (task) => task.id === targetCardId,\n      );\n      if (targetIndex === -1) return;\n      const finalIndex =\n        closestEdge === \"bottom\" ? targetIndex + 1 : targetIndex;\n\n      // Get the dragging task from source column\n      const draggingTask = getTasksByColumnId(sourceColumnId, dataSource).find(\n        (task) => task.id === draggingCardId,\n      );\n      if (!draggingTask) return;\n\n      // Create a temporary array with the dragging task inserted at the target position\n      const tempArray = [...allTargetTasks];\n      tempArray.splice(finalIndex, 0, draggingTask);\n\n      // Use reorderWithEdge to get the correct final position\n      const reordered = reorderWithEdge({\n        axis: \"vertical\",\n        list: tempArray,\n        startIndex: finalIndex,\n        indexOfTarget: finalIndex,\n        closestEdgeOfTarget: closestEdge,\n      });\n\n      // Calculate the new position based on the reordered array\n      const newPosition = reordered.findIndex(\n        (task) => task.id === draggingCardId,\n      );\n\n      const taskAbove = newPosition > 0 ? reordered[newPosition - 1] : null;\n      const taskBelow =\n        newPosition < reordered.length - 1 ? reordered[newPosition + 1] : null;\n\n      if (onCardMove) {\n        onCardMove({\n          cardId: draggingCardId,\n          fromColumnId: sourceColumnId,\n          toColumnId: targetColumnId,\n          taskAbove: taskAbove?.id,\n          taskBelow: taskBelow?.id,\n          position: newPosition,\n        });\n      }\n    }\n  }\n  // Case 2: Dropping directly on a column (not on a card)\n  else if (isColumnData(dropTargetData)) {\n    const targetColumnId = dropTargetData.columnId;\n    const targetTasks = getTasksByColumnId(targetColumnId, dataSource);\n    const taskAbove =\n      targetTasks.length > 0 ? targetTasks[targetTasks.length - 1] : null;\n\n    if (onCardMove) {\n      onCardMove({\n        cardId: draggingCardId,\n        fromColumnId: sourceColumnId,\n        toColumnId: targetColumnId,\n        taskAbove: taskAbove?.id,\n        taskBelow: null,\n        position: targetTasks.length,\n      });\n    }\n  }\n};\n\nexport const dropColumnHandler = (\n  drop: { columnId: string; position: number },\n  dataSource: BoardData,\n) => {\n  const { columnId, position } = drop;\n  const newDataSource = { ...dataSource };\n  const rootChildren = [...(newDataSource[\"root\"]?.children || [])];\n  const currentIndex = rootChildren.indexOf(columnId);\n\n  if (currentIndex === -1) return newDataSource;\n\n  rootChildren.splice(currentIndex, 1);\n  rootChildren.splice(position, 0, columnId);\n  if (newDataSource[\"root\"]) {\n    newDataSource[\"root\"].children = rootChildren;\n  }\n  return newDataSource;\n};\n\nexport const dropHandler = (\n  drop: {\n    cardId: string;\n    fromColumnId: string;\n    toColumnId: string;\n    taskAbove: string | null;\n    taskBelow: string | null;\n  },\n  dataSource: BoardData,\n  updateDroppedItem?: (targetColumn: BoardItem, droppedItem: any) => any,\n  updateDestinationColumn?: (targetColumn: BoardItem) => any,\n  updateSourceColumn?: (sourceColumn: BoardItem) => any,\n) => {\n  const { cardId, fromColumnId, toColumnId, taskAbove, taskBelow } = drop;\n\n  const newDataSource = { ...dataSource };\n\n  if (newDataSource[fromColumnId]?.children) {\n    newDataSource[fromColumnId].children = newDataSource[\n      fromColumnId\n    ].children.filter((id: string) => id !== cardId);\n    if (\n      newDataSource[fromColumnId]?.totalItems !== undefined &&\n      newDataSource[fromColumnId].totalItems > 0\n    )\n      newDataSource[fromColumnId].totalItems--;\n  }\n\n  if (updateSourceColumn && newDataSource[fromColumnId])\n    newDataSource[fromColumnId] = updateSourceColumn(\n      newDataSource[fromColumnId],\n    );\n\n  const targetChildren = newDataSource[toColumnId]?.children || [];\n  let insertIndex = 0;\n\n  if (taskAbove) insertIndex = targetChildren.indexOf(taskAbove) + 1;\n  else if (taskBelow) insertIndex = targetChildren.indexOf(taskBelow);\n\n  const alreadyExistInTarget = targetChildren.includes(cardId);\n\n  if (\n    newDataSource[toColumnId]?.totalItems !== undefined &&\n    !alreadyExistInTarget\n  )\n    newDataSource[toColumnId].totalItems++;\n\n  if (updateDroppedItem && newDataSource[cardId]) {\n    const updatedItem = updateDroppedItem?.(\n      newDataSource[toColumnId],\n      newDataSource[cardId],\n    );\n    newDataSource[cardId] = updatedItem || newDataSource[cardId];\n  }\n\n  if (newDataSource[toColumnId]?.children) {\n    newDataSource[toColumnId].children = newDataSource[\n      toColumnId\n    ]?.children?.filter((id: string) => id !== cardId);\n    newDataSource[toColumnId].children.splice(insertIndex, 0, cardId);\n  }\n\n  if (updateDestinationColumn && newDataSource[toColumnId])\n    newDataSource[toColumnId] = updateDestinationColumn(\n      newDataSource[toColumnId],\n    );\n\n  return newDataSource;\n};\n"],"names":["isCardData","data","type","isColumnData","getTasksByColumnId","columnId","dataSource","tasks","column","parentTasks","children","forEach","taskId","task","push","handleCardDrop","source","location","columns","onCardMove","onColumnMove","sourceColumnId","innerMost","current","dropTargets","dropTargetData","targetColumnId","targetIndex","findIndex","col","id","fromIndex","toIndex","draggingCardId","itemId","targetCardId","closestEdge","extractClosestEdge","sourceColumn","targetColumn","allTasks","sourceIndex","reordered","reorderWithEdge","axis","list","startIndex","indexOfTarget","closestEdgeOfTarget","newPosition","taskAbove","taskBelow","length","cardId","fromColumnId","toColumnId","position","allTargetTasks","finalIndex","draggingTask","find","tempArray","splice","targetTasks","dropColumnHandler","drop","newDataSource","rootChildren","currentIndex","indexOf","dropHandler","updateDroppedItem","updateDestinationColumn","updateSourceColumn","filter","totalItems","undefined","targetChildren","insertIndex","alreadyExistInTarget","includes","updatedItem"],"mappings":"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"}