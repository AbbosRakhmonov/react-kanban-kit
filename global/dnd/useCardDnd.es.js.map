{"version":3,"file":"useCardDnd.es.js","sources":["../../../src/global/dnd/useCardDnd.tsx"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from \"react\";\nimport { BoardItem, DndState } from \"@/components/types\";\nimport {\n  draggable,\n  dropTargetForElements,\n} from \"@atlaskit/pragmatic-drag-and-drop/element/adapter\";\nimport {\n  attachClosestEdge,\n  extractClosestEdge,\n  Edge,\n} from \"@atlaskit/pragmatic-drag-and-drop-hitbox/closest-edge\";\nimport { combine } from \"@atlaskit/pragmatic-drag-and-drop/combine\";\nimport { setCustomNativeDragPreview } from \"@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview\";\nimport { preserveOffsetOnSource } from \"@atlaskit/pragmatic-drag-and-drop/element/preserve-offset-on-source\";\nimport { useKanbanContext } from \"@/context/KanbanContext\";\n\nexport type TaskCardState =\n  | {\n      type: \"idle\";\n    }\n  | {\n      type: \"is-dragging\";\n    }\n  | {\n      type: \"is-dragging-and-left-self\";\n    }\n  | {\n      type: \"is-over\";\n      dragging: DOMRect;\n      closestEdge: Edge;\n    }\n  | {\n      type: \"preview\";\n      container: HTMLElement;\n      dragging: DOMRect;\n    };\n\nconst idle: TaskCardState = { type: \"idle\" };\n\n// Custom hook to handle all drag and drop logic\nexport const useCardDnd = (\n  data: BoardItem,\n  column: BoardItem,\n  index: number,\n  isDraggable: boolean,\n  onCardDndStateChange?: (info: DndState) => void,\n) => {\n  const { viewOnly } = useKanbanContext();\n  const outerRef = useRef<HTMLDivElement>(null);\n  const innerRef = useRef<HTMLDivElement>(null);\n  const [state, setState] = useState<TaskCardState>(idle);\n\n  // Memoize initial data to prevent recreating on each render\n  const getInitialData = useCallback(\n    () => ({\n      type: \"card\",\n      itemId: data.id,\n      columnId: column.id,\n      index,\n      isDraggable,\n      parentId: data.parentId,\n      rect: innerRef.current?.getBoundingClientRect() || null,\n    }),\n    [data.id, column.id, index, isDraggable, data.parentId],\n  );\n\n  const getDropTargetData = useCallback(\n    ({ input, element }) => {\n      const cardData = {\n        type: \"card\",\n        \"card-drop-target\": true,\n        itemId: data.id,\n        columnId: column.id,\n        index,\n        isDraggable,\n        parentId: data.parentId,\n      };\n\n      return attachClosestEdge(cardData, {\n        input,\n        element,\n        allowedEdges: [\"top\", \"bottom\"],\n      });\n    },\n    [data.id, column.id, index, isDraggable, data.parentId],\n  );\n\n  // Optimize the drop check to avoid recalculating on every drag move\n  const canDrop = useCallback(\n    (args) => {\n      const sourceData = args.source.data;\n      if (sourceData.itemId === data.parentId) return false;\n      return sourceData.isDraggable;\n    },\n    [data.id, data.parentId],\n  );\n\n  // Drag and drop event handlers\n  const handleGenerateDragPreview = useCallback(\n    ({ nativeSetDragImage, location }) => {\n      setCustomNativeDragPreview({\n        nativeSetDragImage,\n        getOffset: preserveOffsetOnSource({\n          element: innerRef.current!,\n          input: location.current.input,\n        }),\n        render({ container }) {\n          const rect = innerRef.current!.getBoundingClientRect();\n          setState({\n            type: \"preview\",\n            container,\n            dragging: rect,\n          });\n        },\n      });\n    },\n    [],\n  );\n\n  const handleDragStart = useCallback(() => {\n    setState({ type: \"is-dragging\" });\n  }, []);\n\n  const handleDrop = useCallback(() => {\n    setState(idle);\n  }, []);\n\n  const handleDragEnter = useCallback(\n    ({ source, self }) => {\n      if (source.data.type !== \"card\") return;\n      if (source.data.itemId === data.id) return;\n\n      const closestEdge = extractClosestEdge(self.data);\n      if (!closestEdge) return;\n\n      setState({\n        type: \"is-over\",\n        dragging: source.data.rect as DOMRect,\n        closestEdge,\n      });\n    },\n    [data.id],\n  );\n\n  const handleDrag = useCallback(\n    ({ source, self }) => {\n      if (source.data.type !== \"card\") return;\n      if (source.data.itemId === data.id) return;\n\n      const closestEdge = extractClosestEdge(self.data);\n      if (!closestEdge) return;\n\n      setState({\n        type: \"is-over\",\n        dragging: source.data.rect as DOMRect,\n        closestEdge,\n      });\n    },\n    [data.id],\n  );\n\n  const handleDragLeave = useCallback(\n    ({ source }) => {\n      if (source.data.type !== \"card\") return;\n\n      if (source.data.itemId === data.id) {\n        setState({ type: \"is-dragging-and-left-self\" });\n        return;\n      }\n\n      setState(idle);\n    },\n    [data.id],\n  );\n\n  // Setup drag and drop effects\n  useEffect(() => {\n    const outer = outerRef.current;\n    const inner = innerRef.current;\n\n    if (!outer || !inner) return;\n\n    return combine(\n      draggable({\n        element: inner,\n        getInitialData,\n        onGenerateDragPreview: handleGenerateDragPreview,\n        onDragStart: handleDragStart,\n        onDrop: handleDrop,\n        canDrag: () => isDraggable && !viewOnly,\n      }),\n      dropTargetForElements({\n        element: outer,\n        canDrop,\n        getIsSticky: () => true,\n        getData: getDropTargetData,\n        onDragEnter: handleDragEnter,\n        onDrag: handleDrag,\n        onDragLeave: handleDragLeave,\n        onDrop: handleDrop,\n      }),\n    );\n  }, [\n    getInitialData,\n    handleGenerateDragPreview,\n    handleDragStart,\n    handleDrop,\n    isDraggable,\n    canDrop,\n    getDropTargetData,\n    handleDragEnter,\n    handleDrag,\n    handleDragLeave,\n  ]);\n\n  useEffect(() => {\n    onCardDndStateChange?.({ state, card: data, column });\n  }, [state, onCardDndStateChange]);\n\n  return {\n    outerRef,\n    innerRef,\n    state,\n  };\n};\n"],"names":["idle","type","useCardDnd","data","column","index","isDraggable","onCardDndStateChange","viewOnly","useKanbanContext","outerRef","useRef","innerRef","state","setState","useState","getInitialData","useCallback","itemId","id","columnId","parentId","rect","current","getBoundingClientRect","getDropTargetData","input","element","cardData","attachClosestEdge","allowedEdges","canDrop","args","sourceData","source","handleGenerateDragPreview","nativeSetDragImage","location","getOffset","preserveOffsetOnSource","render","container","dragging","handleDragStart","handleDrop","handleDragEnter","self","closestEdge","extractClosestEdge","handleDrag","handleDragLeave","useEffect","outer","inner","combine","draggable","onGenerateDragPreview","onDragStart","onDrop","canDrag","dropTargetForElements","getIsSticky","getData","onDragEnter","onDrag","onDragLeave","card"],"mappings":"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"}